For partA: in server: we first create a struct which can be treated as a shared memo. in the main method: first we create and initialize the shared memory page, then we make the file to be truncated to a precise size in bytes, next, we map the shared memory segment to address space of process. Secondly, we made a pointer mutex to point to the segment of shared memory page. Thirdly, we initialized the rest of the segments in the shared memory page. Fourthly, we used a while loop to read and display information. In client: we enable multiple clients to connect simultaneously to the same server and same shared memory page. In the critical segment, we mark its segment as a valid one then the segment can be used by other clients later. Finally we enabled both server and client to exit gracefully. In the critical section, we let client search the segments of the page in order to find a valid segment and then mark it to be invalid. Then we printed the client.
For partB, 
In vm.c, modify the inituvm method to map the init point to 0x2000 and modify the copyuvm methodï¼Œ since the AS is rearranged as the stack is move to top and the first 2 pages are marked invalid. In syscall.c, add validateAS method to ensure the accessed addr is valid within the AS.In exec.c, change allocation to let the start  at the USERTOP of the user address space, instead of between the code and heap. In proc.c, growing heap so that stack will not be overwritten and leave 5 unallocated pages between the stack and heap. In trap.c, make the stack grow backwards when needed. If a fault occurred on the page right below the stack bottom and then we allocated a new page, map it into the address space, and continue run. Change makefile in user folder to location in memory where the program will be loaded. Change makefile, and let the entry point point to 0x2000.